\documentclass{article}

\usepackage{amsmath}
\usepackage[margin=1cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}

\title{
    \textbf{Programming Club}\\
    Fractals
}
\author{Hugh Leather}
\date{10$^{th}$ January 2018}

\begin{document}
    \maketitle

    \section{Output to a file} 
    
        We are going to draw our pictures into files. That means that first we need to be able to write into a file. 
        \paragraph{Task: ``Hello, File!''}
            Try to write a program to print ``\texttt{Hello, File!}'' to a file called \texttt{hello.txt}.

            Below we'll look at all the bits you will need, step by step. At each step, try to work it out yourself first, making use of
            the online documentation, using these notes only if you need to.
        
        \paragraph{\texttt{PrintStream}}
            
            Fortunately, in Java, writing to files is pretty easy. You will probably want to look at the package documentation for the
            \texttt{java.io} package at some point
            (\url{https://docs.oracle.com/javase/8/docs/api/index.html?java/io/package-summary.html}).
     
            The idea is that we create a \texttt{PrintStream}\footnote{It would probably be a bit more modern to use a
            \texttt{PrintWriter}.} which has operations like \texttt{println} that print text to a file. You have probably already seen a
            \texttt{PrintStream} when you use \texttt{System.out.println}. In that code, \texttt{System.out} is a \texttt{PrintStream} that
            prints to the standard output.
        
        \paragraph{A main class.} 
        
            You will have to write a Java class. Let's call it \texttt{FileOutputTest}. This is going to be a public class (the public bit
            just means everyone can see it). In Java, any top level public class needs to go in a file of the same name with a
            \texttt{.java} extension. So, we'll put the class in file \texttt{FileOutputTest.java}.
            
            This file is just going to have a \texttt{main} method which will be called when we run the program. We'll add more to it later.
            
            \begin{minted}[autogobble]{Java}
                public class FileOutputTest {
                    public static void main(String[] args) {
                        System.out.println("Hello, World!")
                    }
                }
            \end{minted}
        
            For now, you should be able to compile this class with:
            \begin{minted}[autogobble]{Bash}
                javac FileOutputTest.java
            \end{minted}
            
            And then run it with:
            \begin{minted}[autogobble]{Bash}
                java FileOutputTest
            \end{minted}
        
            If all has gone well, it should print ``\texttt{Hello, World!}''
            
        \paragraph{Print to a file instead.}
            
            To print to a file, you need to create a new \texttt{PrintStream}. You can do this by adding this to your \texttt{main} method:
            \begin{minted}[autogobble]{Java}
                java.io.PrintStream ps = new java.io.PrintStream("hello.txt");
            \end{minted}
            Just a quick note: if you are using Java 10, you can just write 
            \begin{minted}[autogobble]{Java}
                var ps = new java.io.PrintStream("hello.txt");
            \end{minted}
            
            Now you can print to that stream:
            \begin{minted}[autogobble]{Java}
                ps.println("Hello, File!");
            \end{minted}
            
            When you're finished with the file you have to close it, otherwise not all the text may get written:
            \begin{minted}[autogobble]{Java}
                ps.close();
            \end{minted}
            
        \paragraph{Exceptions.}

            But, if you try to compile this, it won't work. It will complain that \texttt{FileNotFoundException} has not been handled. Java
            is quite picky about somethings. In this case it is saying that \texttt{new java.io.PrintStream("hello.txt")} can fail and
            someone had better agree to do something about it.

            There are several ways we can fix this. The first is to say, hey someone else can deal with it. This means that it will be the
            problem of whoever calls \texttt{main}. This is okay, the \texttt{java} program will report the exception if it gets it.
            To do this, we say that \texttt{main} might throw this exception out. Then Java is happy again and we can compile it.
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
            \end{minted}
             
            A better way is to catch the error do something sensible about it using a \texttt{try} and \texttt{catch}.
             
            Even better is to use \texttt{try} with resource.
             
             We might come back to those another time.
        
        \paragraph{Imports} 
            When you use \texttt{PrintStream}, you have to either use its full name (\texttt{java.io.PrintStream}), or you can import that
            name so that thereafter you can just use \texttt{PrintStream} by itself. At the top of your Java file, you can write this to
            import the name.
        
            \begin{minted}[autogobble]{Java}
                import java.io.PrintStream;
            \end{minted}
        
            But, we're probably going to use several names from that package, so we can bring them all in at once by using this import:
            \begin{minted}[autogobble]{Java}
                import java.io.*;
            \end{minted}
        
        \paragraph{The final code}
            This should be what we end up with:
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                public class FileOutputTest {
                    public static void main(String[] args) throws FileNotFoundException {
                        PrintStream ps = new PrintStream("hello.txt");
                        ps.println("Hello, File!");
                        ps.close();
                    }
                }
            \end{minted}
        
            Compile it, run it, and check that it writes to \texttt{hello.txt}.

    \section{A first picture}
     
        The simplest picture format you might use is PPM. You can write out the image to a file in this format and then view it on your
        desktop. There several different PPM types, but the easiest for us is P3, which will allow everything to be written in text, rather
        than binary. It lets us build up pixels of red, green, and blue components quite simply.
        
        \paragraph{P3 format}
            The basic structure of the file is like this:
        
            \begin{minted}[autogobble]{Java}
                P3
                <width> <height>
                <max>
                <r> <b> <g>   <r> <b> <g>  <r> <b> <g> ...
                <r> <b> <g>   <r> <b> <g>  <r> <b> <g> ...            
            \end{minted}

            All of these numbers are given as ordinary decimals. The \texttt{width} and \texttt{height} are the number of pixels wide and
            high the image is. \texttt{max} is the largest value any of red, green, and blue could take. I.e. fully on. A simple value for
            this is 255, which will work for bytes and give you $2^24$ different colours. Each of \texttt{r}, \texttt{g}, and \texttt{b}
            are values between 0 and \texttt{max} inclusive, giving the amount of that colour for the appropriate pixel. The pixels are
            arranged so that the rows are done first, with the very first pixel being the top left of the image.
        
            Between each element of the file, there has to be some whitespace. These can be any number of spaces, tabs, or newlines.
            \textbf{The last character of the file has to be whitespace!}
        
        \paragraph{Task: Make a heart}
            
            Since Valentine's day is coming soon, make a very small image, just using your text editor.  It should look like this:

                \includegraphics[width=0.5\textwidth]{code/heart.jpg}
        
            I admit, it's not a very good heart.
            
        \paragraph{The heart file}
            Here's what the file should look like.  Remember to have some whitespace at the very end.
            \begin{minted}[autogobble]{Java}
                P3
                5 4
                255
                0 0 0       255 0 0     0 0 0       255 0 0     0 0 0 
                255 0 0     255 0 0     255 0 0     255 0 0     255 0 0
                0 0 0       255 0 0     255 0 0     255 0 0     0 0 0
                0 0 0       0 0 0       255 0 0     0 0 0       0 0 0
            \end{minted}            

        \paragraph{Task: A Java heart}
            Use Java to write out the heart file instead.  
            
            Add two static variables for the height and width of the picture. Add three arrays of \texttt{float}s for the red, green, and
            blue pixels (we'll use \texttt{0.0} for black and \texttt{1.0} for fully read, green, or blue). Add a function to convert from
            a \texttt{float} between \texttt{0.0} and \texttt{1.0} into an integer between 0 and 255. Add a function to write the image to
            a file. Write it.
        
        \paragraph{Adding some variables}
            Let's make a new class and add some variables to it.  Put this code into \texttt{Heart.java}.
            
            Note that all the variables are \texttt{static}.  This makes them available from \texttt{static} methods like main.
            
            Also, we could have used a multidimensional array for each of the colours, but this works as well. You have to convert though
            from your \texttt{x} and \texttt{y} coordinates into a single index.
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                
                public class Heart {
                    static int width = 5;
                    static int height = 4;
                    
                    static float[] red = new float[width * height];
                    static float[] green = new float[width * height];
                    static float[] blue = new float[width * height];
                    
                    public static void main(String[] args) {
                    }
                }
            \end{minted}
        \newpage
        \paragraph{Setting a pixel}
            Let's add a function to set the value of a pixel.

            Note that we convert x and y to an index - we should probably do some bounds checking there, eh?

            \begin{minted}[autogobble]{Java}
                static void set(int x, int y, float r, float g, float b) {
                    int i = x + y * width;
                    red[i] = r;
                    green[i] = g;
                    blue[i] = b;
                }
            \end{minted}
        
        \paragraph{Convert a channel value to an \texttt{int}}
            Converting channels (i.e. values of red, green, or blue pixels) into integers for the file isn't too bad.  
            
            We want \texttt{0.0} to map to \texttt{0}.
            
            We want \texttt{1.0} to map to \texttt{255}.
            
            We want an even spread between.
            
            So this equation will do:\footnote{Actually this isn't quite right since really we want the interval $(1-\epsilon,1]$ to map to 255. What would $\epsilon$ be? How would you change the rest?} 
            $colour \rightarrow colour \times 255$
            
            \begin{minted}[autogobble]{Java}
                static int colourToInt(float c) {
                    return (int)(c * 255);
                }
            \end{minted}

            Now you will notice that there is a bit in there which ``casts to an int''. That is because Java complains if you try to
            convert from one type to another where you might lose information.  The cast says that this really is what you want.
            
        \paragraph{Writing out an image}
            Let's add a method called \texttt{write} to dump the image to a file.  It should take a file name as a string.
            
            Note that this code might throw and exception, so we need to let anyone using it know that.
            
            \begin{minted}[autogobble]{Java} 
                static void write(String fileName) throws FileNotFoundException {
                    PrintStream ps = new PrintStream(fileName);
                    ps.println("P3");
                    ps.println(width + " " + height);
                    ps.println(255);
                    
                    for(int i = 0; i < width * height; ++i) {
                        ps.print(colourToInt(red[i]) + " ");
                        ps.print(colourToInt(green[i]) + " ");
                        ps.print(colourToInt(blue[i]) + " ");
                    }
                    
                    ps.close();
                }
            \end{minted}
        
        \newpage
        \paragraph{Making the heart}
            Let's fill up the pixels in the \texttt{main} method and then write out the file.
            
            Note that the array values are filled with zeros to start with, so we only have to set the red pixels.
            
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
                    // Set the pixels
                    set(1,0, 1,0,0);
                    set(3,0, 1,0,0);
                    
                    set(0,1, 1,0,0);
                    set(1,1, 1,0,0);
                    set(2,1, 1,0,0);
                    set(3,1, 1,0,0);
                    set(4,1, 1,0,0);
                    
                    set(1,2, 1,0,0);
                    set(2,2, 1,0,0);
                    set(3,2, 1,0,0);
                    
                    set(2,3, 1,0,0);
                    
                    // Write out the file
                    write("heart-from-java.ppm");
                }
            \end{minted}

    \newpage
    \section{A smooth image}
        See if you can make an image, 200 by 100 pixels, that looks like this:
        
        \includegraphics{code/smooth.jpg}
        
        \paragraph{Looping over the pixels}
            This might look pretty easy, but there's a little trap waiting for you, which we'll get to in a bit.
            
            First of all copy the previous code into a new file and change the class name.  Maybe \texttt{Smooth.java} and \texttt{Smooth}
            respectively.
            
            Then you'll need to change the width and height of the image:
            \begin{minted}[autogobble]{Java}
                import java.io.*;
                
                public class Smooth {
                    static int width = 200;
                    static int height = 100;
                    //...
            \end{minted}
            
            Now we replace the main method which builds the image (including sending it to a different file). We'll make a couple of
            \texttt{for} loops. The first will iterate over the \texttt{x} axis, the second will iterate over the \texttt{y} axis.

            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) throws FileNotFoundException {
                    for(int x = 0; x < width; ++x) {
                        for(int y = 0; y < height; ++y) {
                            // Set the colour for (x, y) here
                        }
                    }
                    // Write out the file
                    write("smooth.ppm");
                    
                }
            \end{minted}
        
            How do you set the colour for \texttt{(x, y)}? Well, you want the \texttt{x} axis to change the red channel from 0 to 1, and
            the \texttt{y} axis to change the blue channel from 0 to 1. So it should look like this, right?
            
            \begin{minted}[autogobble]{Java}
                set(x,y, x/width,0,y/height);
            \end{minted}
            
            Try it. What happens?
        
        \paragraph{Watch out for integer division}
            Hmm, the last thing made an image of the right size, but all the pixels were black.  What went wrong?
            
            Well, if you look at the types of \texttt{x} and \texttt{width}, you will see they are both integers. Integer division rounds
            down, so instead of a number between \texttt{0.0} and \texttt{1.0}, you get \texttt{0}. Then that is converted from an integer
            version of zero to floating point version of zero - i.e. \texttt{0.0}.
            
            What we need to do is to tell Java that we really want to do this with floating point division, not integer division. 
            
            The easy way is to tell it that one of the numbers is a \texttt{float}:
            \begin{minted}[autogobble]{Java}
                set(x,y, x/(float)width,0,y/(float)height);
            \end{minted}
            
            Phew, now everything works.

    \newpage
    \section{An Image Object}
    
        So this code that we've written is okay. But it's a bit painful to use. Each time you need a new picture you have to make a new
        class file for the image. And, you have to manually copy over all the \texttt{width} and \texttt{height} fields, as well as the
        methods we wanted, like \texttt{set} and \texttt{write}. It is hardly ideal, is it?
        
        I guess what we'd like is to be able to have lots of images kicking around all at once, but have them share most of the
        functionality. Java makes this easy by giving us objects.
        
        With the \texttt{static} fields in the classes we've made, there is only one copy per class. With objects, there is a copy per
        object, and you make as many objects as you like, even inside a loop. In fact, Java expects you to use objects so much that they
        are the default, you have to mention if something is static specifically.
        
        \paragraph{Make an Image class.}
            Try to work out how to do this yourself!
            
        \paragraph{Okay, I'll show you :-)}
            %
            First, let's make a new Java file for our class. We'll call it \texttt{Image.java}. 
            
            Copy in everything from the other files except the \texttt{main} method and don't use the word \texttt{static}. Non static
            things belong to a particular object.
            
            In fact, wherever you had \texttt{static}, use the word \texttt{public}. This means that Java will let you use that name from
            outside the object. I think Volker is going to discuss both \texttt{static} and \texttt{public} in Inf1OP at some point, so I
            won't go into them in much detail.

            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class Image {
                    public int width;
                    public int height;
    
                    public float[] red = new float[width * height];
                    public float[] green = new float[width * height];
                    public float[] blue = new float[width * height];    

                    public void set(int x, int y, float r, float g, float b) {
                        int i = x + y * width;
                        red[i] = r;
                        green[i] = g;
                        blue[i] = b;
                    }

                    public int colourToInt(float c) {
                        return (int)(c * 255);
                    }
                    public void write(String fileName) throws FileNotFoundException {
                        PrintStream ps = new PrintStream(fileName);
                        ps.println("P3");
                        ps.println(width + " " + height);
                        ps.println(255);
        
                        for(int i = 0; i < width * height; ++i) {
                            ps.print(colourToInt(red[i]) + " ");
                            ps.print(colourToInt(green[i]) + " ");
                            ps.print(colourToInt(blue[i]) + " ");
                        }
        
                        ps.close();
                    }
                    
                }
            \end{minted}
        
        \newpage
        \paragraph{Make a new image}
            %
            So now we we can make as many images as we want. But how do we use them?
            
            Let's make the \emph{smooth} image using our object class.  We'll put it in class \texttt{SmoothObj}
            
            To make a new object, use \texttt{new}.  For the image, we would use:

            \begin{minted}[autogobble]{Java}
                Image img = new Image();
            \end{minted}
            
            Now wherever previously you used a static variable or method, call \texttt{img}'s version instead.     
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothObj {

                    public static void main(String[] args) throws FileNotFoundException {
                        Image img = new Image();
                        img.width = 200;
                        img.height = 100;
                        
                        // Set the pixels
                        for(int x = 0; x < img.width; ++x) {
                            for(int y = 0; y < img.height; ++y) {
                                img.set(x,y, x/(float)img.width,0,y/(float)img.height);
                            }
                        }
                        // Write out the file
                        img.write("smooth.ppm");
                    }
                }
            \end{minted}
                    
            You could now have as many images as you'd like.
            
            Eeek, this didn't work!  Why not?

        \paragraph{An image constructor}
            %
            When you made a new new \texttt{Image}, did you notice that there were parentheses after \texttt{Image}? This might be a bit
            suggestive to you that maybe you could put function parameters there.  Well, yes, you can.
            
            We currently have to tell Java after we constructed the \texttt{Image} what it's width and height are.  That could be dangerous.
            
            In fact, it was dangerous for us! You may have noticed that you got an \texttt{java.lang.ArrayIndexOutOfBoundsException} when
            running the previous code. The reason for this is that we didn't set the \texttt{Image}'s \texttt{width} or \texttt{height}
            before making the arrays for \texttt{red}, \texttt{green}, and \texttt{blue}. In java, when you don't initialise a field, it is
            set to \texttt{0}, if it's a number, or \texttt{null} if it's an object. So, \texttt{width} and \texttt{height} were both zero
            when the arrays were created. Then, when we tried to set a pixel, the index we chose `fell off' the end of the array.
            
            By using constructors and then not letting other people access critical bits of a class, we can make sure that things are
            always in a good state. A constructor is an object method with special name, the same name as the class. Also, it doesn't
            return anything, you can only call it during \texttt{new}, and there are some other rules about what they have to do which we
            won't worry about just now.
            
            Let's make a constructor for our \texttt{Image} class that takes the \texttt{width} and \texttt{height}, and then creates the
            arrays for the colours.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    public int width;
                    public int height;
    
                    public float[] red;
                    public float[] green;
                    public float[] blue;    
            
                    public Image(int w, int h) {
                        width = w;
                        height = h;
                        red = new float[width * height];
                        green = new float[width * height];
                        blue = new float[width * height];
                    }
                    // ...
            \end{minted}
            
            Great! But now the \texttt{new} call in \texttt{SmoothObj} doesn't work because we don't have a constructor which takes no
            arguments.  Let's change that.
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothObj {

                    public static void main(String[] args) throws FileNotFoundException {
                        Image img = new Image(200, 100);
                        
                        // Set the pixels
                        for(int x = 0; x < img.width; ++x) {
                            for(int y = 0; y < img.height; ++y) {
                                img.set(x,y, x/(float)img.width,0,y/(float)img.height);
                            }
                        }
                        // Write out the file
                        img.write("smooth.ppm");
                    }
                }
            \end{minted}
        
        \paragraph{Finally secure}
            %
            BTW, the things we're doing here, up until we talk about Mandelbrots, are just to make things better and to show you more Java.
            If you want to just get on with the pretty pictures, you could skip ahead to Mandelbrots and try to make things work like that.
            
            So, we have a constructor, but we still aren't entirely safe. What if someone changes the \texttt{width} after they've made the
            image? Well, then all hell could break loose. Maybe we should stop them doing that.
            
            In Java, there is a simple way to stop that. We can tell Java that once a field is initialised then it can't ever be changed
            again. We do that with the \texttt{final} keyword.

            \begin{minted}[autogobble]{Java}
                public class Image {
                    public final int width;
                    public final int height;
    
                    public final float[] red;
                    public final float[] green;
                    public final float[] blue;    
            \end{minted}
            
            Do that and see what happens if you try to change \texttt{width}, say by adding one to it.
            
        \paragraph{Complaining about crazy people}
            %
            Okay, so we've protected against crazy people trying to mess with things in the wrong order, but we still aren't safe. What
            would happen if someone used a negative \texttt{width} for the \texttt{Image}? Or what if someone tries to set the pixel at
            \texttt{(-100,5000)}? What if they use colour values outside of the range \texttt{0.0} to \texttt{1.0}? They would probably
            make the universe explode (try it?).
            
            Maybe we should check for this bad things and report something sensible to the user. What we will do is throw an exception.
            That means we tell Java to stop what it's doing and report a problem that someone has to fix or the stop the program if no one
            does. We've already seen that making a \texttt{PrintStream} can throw a \texttt{FileNotFoundException}. It is just like that,
            except for two things. 1) we will throw an \texttt{IllegalArgumentException} instead. 2) Java isn't as persnickety about that
            exception, so we don't need to add it to the list in \texttt{main}, or anywhere else. \footnote{Java has two types of exception. One has
            to be handled or the compiler won't compile your program. They other type (called a \texttt{RuntimeException}) doesn't. It's an
            historical thing, mostly, and not a little bit annoying.}
            
            \begin{minted}[autogobble]{Java}
                public Image(int w, int h) {
                    if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                    if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                    //...
            \end{minted}
            
            Now, if someone tries to make a badly sized image, they will get a nice error about it.  Try it.
            
            Can you make anything else in the \texttt{Image} class safe this way?
            
    \newpage
    \section{Objects, Objects, Everywhere!}
        
        Objects are kind of useful in Java.  They let us make lots of things easier and more natural. Let's turn our attention to colours.
        
        \paragraph{Colour}
            %
            So far, we've been using three separate colour channels to represent our three colours. This means you can't define a constant
            for mauve, say, and then pass it into the \texttt{set} method on the image. You still have to put in the three colours
            individually. It would be much better if we had an idea of a colour object instead that encapsulated the three colour channels
            for us.
        
            So, let's create a \texttt{Colour} class.  What do you think it should look like?
        
            Let's put it in \texttt{Colour.java}.  

            \begin{minted}[autogobble]{Java}
                public class Colour {
                    public final float r, g, b;
                
                    public Colour(float r, float g, float b) {
                        this.r = r;
                        this.g = g;
                        this.b = b;
                    }
                }
            \end{minted}
        
            Now, you might notice that there's a special name used here, \texttt{this}. It refers to the current object. You can imagine
            that there is an extra parameter to a non \texttt{static} method, called \texttt{this} that points to the current object. In
            fact, under the covers, this is exactly what Java does.

            \begin{minted}[autogobble]{Java}                
                public Colour(Colour this, float r, float g, float b)
            \end{minted}
        
            So, now, when we refer to \texttt{this.r}, it means the \texttt{r} belonging to the object itself, not the \texttt{r} passed in.
            This is great because it means we can have the same name appear twice without getting confused.
        
            Oh, notice that we made the \texttt{r}, \texttt{b}, \texttt{g} fields of the \texttt{Colour} object all \texttt{final}. This
            means that \texttt{Colour}s are \emph{immutable}. Immutable objects are a bit safer since they are harder to mess up. Consider
            if we added some \texttt{static} fields into the \texttt{Colour} class for common colours.
        
            \begin{minted}[autogobble]{Java}
                public class Colour {
                    // ...
                    public static final Colour BLACK = new Colour(0,0,0);
                    public static final Colour WHITE = new Colour(1,1,1);
                    public static final Colour RED = new Colour(1,0,0);
                    // ...
                }
            \end{minted}
        
            Notice we made those fields \texttt{final} so no one can swap out \texttt{BLACK} for a different colour which would certainly
            confuse people trying to use \texttt{BLACK} afterwards.
        
            Oh, also notice that this \emph{constant} is spelled with all capital letters. This is standard Java naming practice. You
            should use the standard coding conventions of whatever language you are using - it tends to annoy other developers if you don't.
        
            But, now imagine that the \texttt{r}, \texttt{b}, \texttt{g} fields of the \texttt{Colour} object weren't \texttt{final}. Now
            you could change \texttt{BLACK} into red, which probably wouldn't be the best idea:
        
            \begin{minted}[autogobble]{Java}
                Colour.BLACK.r = 1;
            \end{minted}
        
            Can you finish off the \texttt{Colour} class? Add more standard colours. Add some error checking so people don't give crazy
            numbers to the constructor.
        
        \newpage
        \paragraph{An \texttt{Image} is made of \texttt{Colour}s}
            %
            Let's go ahead and make the \texttt{Image} class have a single array of \texttt{Colour}s rather than individual channels.
            Actually, why don't you try that before we show you? (Don't look below til you've tried it.)
            
            Now, we'll see that, but I'm going to make a few other changes as well which I'll explain afterwards.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    public final int w;
                    public final int h;

                    private final Colour[] pix;

                    public Image(int w, int h) {
                        if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                        if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                        this.w = w;
                        this.h = h;
                        pix = new Colour[w * h];
                        for(int i = 0; i < w * h; ++i) pix[i] = Colour.BLACK;
                    }

                    public void set(int x, int y, Colour c) {
                        if(x < 0 || x >= w || y < 0 || y > h) throw new IllegalArgumentException("Cannot access pixel,"+x+","+y);
                        if(c == null) throw new IllegalArgumentException("Cannot set pixel to null");
                        pix[x + y * w] = c;
                    }
                    public Colour get(int x, int y) {
                        if(x < 0 || x >= w || y < 0 || y > h) throw new IllegalArgumentException("Cannot access pixel,"+x+","+y);
                        return pix[x + y * w];
                    }

                    private int colourToInt(float c) {
                        return (int)(c * 255);
                    }

                    public void write(PrintStream ps) {
                        ps.println("P3");
                        ps.println(w + " " + h);
                        ps.println(255);
        
                        for(Colour p : pix) {
                            ps.print(colourToInt(p.r) + " ");
                            ps.print(colourToInt(p.b) + " ");
                            ps.print(colourToInt(p.g) + " ");
                        }
                    }
    
                    public void write(String fileName) throws FileNotFoundException {
                        PrintStream ps = new PrintStream(fileName);
                        write(ps);
                        ps.close();
                    }
                }
            \end{minted}
        
            What's different here? 
            
            First, I changed the names of \texttt{width} and \texttt{height} to \texttt{w} and \texttt{h}, since we now know we can reuse
            names. This is a pretty pointless change really, but it's good to see where you need to use \texttt{this.w} and \texttt{this.h}.
            
            Then you'll see that the arrays, \texttt{r}, \texttt{b}, and \texttt{g} have been replaced by a single array of
            \texttt{Colour}s, called \texttt{pix}. In the constructor you'll see that gets initialised with \texttt{new}.

            The constructor then fills in each element of \texttt{pix} with \texttt{Colour.BLACK}. That is because a newly created array of
            objects will have each element set to \texttt{null}. We'd much rather the elements had sensible colours to start with.
            
            Now you might also see that the \texttt{pix} array is declared \texttt{private}, not \texttt{public}. This prevents any code
            except that written in the \texttt{Colour} class from messing with the array. If we don't let anyone else change the array,
            then no one can put \texttt{null}s in it which might break our code.
            
            The \texttt{set} method now takes a \texttt{Colour}, rather than individual channels.
            
            Since we have made the \texttt{pix} field private, no one else can access it to write it. But they also can't read it. The
            \texttt{get} method lets people see what's in an image's pixels safely. 
            
            I also changed \texttt{colourToInt} to be \texttt{private} because it's only really for the \texttt{Image} class's internal use.
            
            Finally, I made two versions of \texttt{write}. One works on \texttt{PrintStream}s, the other does the sensible thing with a
            file name. In Java, you can have two methods with the same name if they have different parameter types. Notice that the file
            name version calls the \texttt{PrintStream} version. You can now easily print an image to standard output as well as to files.
            
        \paragraph{Filling an image}
            %
            I had another motivation for wanting use \texttt{Colour} objects rather than three channels. It means that we can return
            colours from a method. This lets us do something cool.
            
            At the moment, you have to set pixels individually or write a couple of nested for loops, iterating over \texttt{x} and
            \texttt{y}.  That latter form is likely to be a common thing to do but it's a bit of pain.  
            
            Suppose we had a type of object with a function that takes an \texttt{Image}, \texttt{x} and \texttt{y} and gives a
            \texttt{Colour}. Maybe it looks like this (put this in a file called \texttt{PixelFn.java}):
        
            \begin{minted}[autogobble]{Java}
                public interface PixelFn {
                    Colour apply(Image img, int x, int y);
                }
            \end{minted}
            
            We could then have a method in our \texttt{Image} class which takes one of these functions and fills in the pixels:

            \begin{minted}[autogobble]{Java}
                public void fill(PixelFn f) {
                    for( int x = 0; x < w; ++x) {
                        for( int y = 0; y < h; ++y) {
                            set(x, y, f.apply(this, x, y));
                        }
                    }
                }
            \end{minted}
            
            That would mean that we could fill an entire image with just one line of code if we had a suitable \texttt{PixelFn}.
            
            But, wait a second! What is all that going on with \texttt{PixelFn}? I said it was a \emph{class}, but it says
            \texttt{interface}. And, the method doesn't have an implementation, and the method isn't \texttt{public}.
            
            An interface is a very special type of type which gets added to other classes to let you share types. We might use it like this:

            \begin{minted}[autogobble]{Java}
                pubic class Reddish implements PixelFn {
                    public Colour apply(Image img, int x, int y) {
                        return Colour(x/(float)img.r);
                    }
                }
            \end{minted}
            
            This says \texttt{Reddish} is also an PixelFn, so you can use it wherever you would use an \texttt{PixelFn}.

            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) {
                    Image img = new Image(200, 100);
                    img.fill(new Reddish());
                    img.write(System.out);
                }
            \end{minted}
            
            That looks a bit better, but Java has something really cool to make this even better.

        \newpage
        \paragraph{Lambda functions!}
            %
            Java has a pretty cool way of making these little classes which are only used to pass forward a method. They are called
            \emph{lambda}s. They are definitely worth you while Googling about. Here, I'm just going to show you how we can use them, but I
            won't go into too much explanation (you can always ask a helper).
            
            We do two things. The first is to declare that \texttt{PixelFn} is one of these special little classes. Java uses something
            called an \emph{annotation} for this. An annotation just tags a class with some extra information. To do it for
            \texttt{PixelFn}, we add this:
            
            \begin{minted}[autogobble]{Java}
                @FunctionalInterface
                public interface PixelFn {
                    Colour apply(Image img, int x, int y);
                }
            \end{minted}
            
            Now, when we use it in the \texttt{fill} method, we can create an \texttt{PixelFn} with some pretty cool syntax:
            
            \begin{minted}[autogobble]{Java}
                public static void main(String[] args) {
                    Image img = new Image(200, 100);
                    img.fill(
                        (im, x, y) -> new Colour(x/(float)im.w, y/(float)im.h, 0)
                    );
                    img.write(System.out);
                }
            \end{minted}
            
            That bit inside of \texttt{fill} implicitly makes an \texttt{PixelFn} whose \texttt{apply} method makes that \texttt{Colour}.
            It's really quite neat.
            
            Now that we've got this, we can also add another constructor to \texttt{Image}, since often we'd want to fill the image as soon
            as we make it.
            
            \begin{minted}[autogobble]{Java}
                public class Image {
                    // ...
                    public Image(int w, int h, PixelFn f) {
                        if(w <= 0) throw new IllegalArgumentException("width must be > 0");
                        if(h <= 0) throw new IllegalArgumentException("width must be > 0");
                        this.w = w;
                        this.h = h;
                        pix = new Colour[w * h];
                        fill(f);
                    }
                    // ...
                }
            \end{minted}
            
            Now, that whole thing to make our smooth image becomes:
            
            \begin{minted}[autogobble]{Java}
                import java.io.*;

                public class SmoothLambda {
                    public static void main(String[] args) throws FileNotFoundException {
                        new Image(200, 100, (im, x, y) -> new Colour(x/(float)im.w, y/(float)im.h, 0)).write("smooth.ppm");
                    }
                }
            \end{minted}
        
            BTW, the \texttt{apply} method's name isn't important. The name comes from functional programming terminology.
        
        \paragraph{Windowed fill}
            %
            Coming soon...
        
\end{document}
